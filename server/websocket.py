import asyncio
import json
import time

from quart import g

from server.utils.utils import GenericJsonEncoder


class WebsocketConnection:
    """
    Simplified object representing a websocket connection.

    Quart does something very interesting in the handler for the websocket
    connection. It does not give us an ordinary object but rather a werkzeug
    LocalProxy that looks like an object with methods (send, receive, close,
    etc.).  However, the dot opererator on the local proxy only works inside
    the context of a websocket request handler. This simple class is meant
    to unpack the useful methods from the local proxy and make them available
    outside that original context. For example, when handling a headset's
    PATCH request, we may need to notify other headsets over websocket.
    """
    def __init__(self, websocket_local_proxy):
        self.close = websocket_local_proxy.close
        self.receive = websocket_local_proxy.receive
        self.send = websocket_local_proxy.send


class WebsocketHandler:
    """
    Handler for a websocket connection.

    Whenever a new websocket connection is accepted, we create a
    WebsocketHandler instance and call the listen method in an asyncio task.
    The listen method waits for messages from the client and takes appropriate
    action. For example, if the client sends a subscribe command, the
    WebsocketHandler forwards this to the event dispatcher.
    """
    def __init__(self, dispatcher, websocket, subprotocol="json", user_id=None, close_after_seconds=60):
        self.dispatcher = dispatcher
        self.websocket = websocket
        self.subprotocol = subprotocol

        # Maintain a list of active subscriptions so that we can clean up
        # when the connection closes.
        self.subscriptions = set()

        # Track last successful send to detect repeated failures.
        self.last_successful_send = time.time()

        self.suppress_own_events = False
        self.user_id = user_id
        self.close_after_seconds = close_after_seconds

        self.running = True

    async def _send_event_notification(self, event, uri, *args, **kwargs):
        # Suppress events that were generated by the same user's actions.  For
        # example, if a headset creates a feature through a POST request, we do
        # not need to send a notification to the same user's websocket
        # connection. This makes sense for headsets, not so much for browser
        # sessions, since a user could have multiple browser sessions open.
        # Hence, the default is off, and the websocket client needs to request
        # suppression be turned on.
        if self.suppress_own_events and g.user_id == self.user_id:
            return

        obj = kwargs

        # For "json" protocol, include event information in the JSON-encoded object.
        if self.subprotocol == "json":
            obj['event'] = event
            obj['uri'] = uri

        body = json.dumps(obj, cls=GenericJsonEncoder)

        # For "json-with-header", the event information appears before the
        # JSON-encoded object.  This gives the receiver a chance to decide how
        # to deserialize the message body.
        if self.subprotocol == "json-with-header":
            payload = "{} {} ".format(event, uri) + body
        else:
            payload = body

        now = time.time()

        try:
            await self.websocket.send(payload)
            self.last_successful_send = now
        except:
            if now - self.last_successful_send > self.close_after_seconds:
                print("WS [{}]: closing connection after repeated send failures".format(self.user_id))
                await self.websocket.close()
                self.remove_subscriptions()
                self.running = False

    def remove_subscriptions(self):
        for event, uri_filter in self.subscriptions:
            self.dispatcher.remove_event_listener(event, uri_filter, self._send_event_notification)

    async def listen(self):
        try:
            while self.running:
                data = await self.websocket.receive()

                words = data.split()
                if len(words) < 2:
                    print("WS [{}]: malformed data from client ({})".format(self.user_id, data))
                    continue

                command = words[0]
                event = words[1]
                uri_filter = words[2] if len(words) > 2 else "*"

                if command == "subscribe":
                    # Disallow duplicate subscriptions.
                    # If the client subscribes multiple times, it is probably a bug.
                    if (event, uri_filter) not in self.subscriptions:
                        print("WS [{}]: subscribe {} {}".format(self.user_id, event, uri_filter))
                        self.dispatcher.add_event_listener(event, uri_filter, self._send_event_notification)
                        self.subscriptions.add((event, uri_filter))

                elif command == "unsubscribe":
                    if (event, uri_filter) in self.subscriptions:
                        print("WS [{}]: unsubscribe {} {}".format(self.user_id, event, uri_filter))
                        self.dispatcher.remove_event_listener(event, uri_filter, self._send_event_notification)
                        self.subscriptions.remove((event, uri_filter))

                elif command == "suppress":
                    if event == "on":
                        self.suppress_own_events = True
                    else:
                        self.suppress_own_events = False

                else:
                    print("WS [{}]: unexpected command {} from client".format(self.user_id, command))

        except asyncio.CancelledError:
            print("WS [{}]: connection closed, removing {} subscriptions".format(self.user_id, len(self.subscriptions)))
            self.remove_subscriptions()

            # Quart documentation warns that the cancellation error needs to be re-raised.
            # https://pgjones.gitlab.io/quart/how_to_guides/websockets.html
            raise
